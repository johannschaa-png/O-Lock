<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>O-Lock</title>

<!-- PWA / iOS Home-Screen (PWA light) -->
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="O-Lock">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<link rel="manifest" href="manifest.webmanifest">
<meta name="format-detection" content="telephone=no">

<style>
html, body {
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
  touch-action: manipulation;
}

body {
  font-family: sans-serif;
  display: flex;
  gap: 20px;
  margin: 20px;
}

#side {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  min-width: 240px;
}

#turnIndicator {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 2px solid black;
}

#status { font-weight: bold; text-align:center; }

#result {
  display: none;
  padding: 10px 12px;
  border: 2px solid #222;
  border-radius: 10px;
  background: #f7f7f7;
  text-align: center;
  font-weight: 700;
  width: 100%;
}

button, select, label {
  padding: 6px 12px;
  cursor: pointer;
}

#board {
  display: grid;
  grid-template-columns: repeat(5, 60px);
  grid-template-rows: repeat(8, 60px);
  gap: 2px;
}

.cell {
  width: 60px;
  height: 60px;
  background: #eee;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
}

.cell.dark { background: #ccc; }
.cell.highlight { background: #8fd18f; }

.red { color: darkred; }
.blue { color: darkblue; }

.piece {
  font-size: 28px;
  pointer-events: none;
}

.small {
  font-size: 12px;
  opacity: 0.85;
  text-align: center;
  line-height: 1.2;
}
</style>
</head>

<body>

<div id="side">
  <div id="turnIndicator"></div>
  <div id="status"></div>
  <div id="result"></div>

  <button onclick="undoMove()">↩ Zug zurück</button>

  <label style="display:flex; gap:8px; align-items:center; user-select:none;">
    <input type="checkbox" id="aiEnabled" checked onchange="AI_ENABLED=this.checked">
    KI (Blau) aktiv
  </label>

  <label style="display:flex; gap:8px; align-items:center;">
    Stärke:
    <select id="aiDepth" onchange="AI_DEPTH=parseInt(this.value,10)">
      <option value="3">3 (leicht)</option>
      <option value="4" selected>4 (mittel)</option>
      <option value="5">5 (stark)</option>
    </select>
  </label>

  <div class="small">
    Regeln (Zusatz):<br>
    • 3× Stellungswiederholung = Remis<br>
    • Schild auf gegnerischer Grundreihe → Umwandlung in A oder D<br>
    • Feedback bei Sieg/Niederlage/Remis
  </div>
</div>

<div id="board"></div>

<script>
/* =====================
   Basisdaten
===================== */
const ROWS = 8, COLS = 5;
let board = [];
let currentPlayer = "red";
let selected = null;
let possibleMoves = [];
let gameOver = false;
const history = [];

// Ergebnis / Feedback
let resultText = "";

// Stellungswiederholung (Hash-Stack)
let positionHistory = []; // enthält Hashes inkl. side-to-move

/* =====================
   KI Einstellungen
===================== */
let AI_ENABLED = true;   // KI spielt Blau
let AI_DEPTH = 4;        // 3=leicht, 4=mittel, 5=stark

/* =====================
   Initialisierung
===================== */
function initBoard() {
  board = Array.from({length: ROWS}, () => Array(COLS).fill(null));

  board[0] = [
    {t:"D",c:"red"}, {t:"A",c:"red"}, {t:"O",c:"red"},
    {t:"A",c:"red"}, {t:"D",c:"red"}
  ];
  board[1] = Array(5).fill(0).map(()=>({t:"S",c:"red"}));

  board[7] = [
    {t:"D",c:"blue"}, {t:"A",c:"blue"}, {t:"O",c:"blue"},
    {t:"A",c:"blue"}, {t:"D",c:"blue"}
  ];
  board[6] = Array(5).fill(0).map(()=>({t:"S",c:"blue"}));
}

function resetGame(){
  gameOver = false;
  resultText = "";
  initBoard();
  currentPlayer = "red";
  selected = null;
  possibleMoves = [];
  history.length = 0;

  positionHistory = [];
  pushPositionHash(); // Startposition zählen

  render();
}

resetGame();

/* =====================
   Rendering
===================== */
function render() {
  const b = document.getElementById("board");
  b.innerHTML = "";

  for (let r = ROWS - 1; r >= 0; r--) {
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement("div");
      cell.className = "cell " + ((r+c)%2 ? "dark" : "");

      if (possibleMoves.some(m=>m.r===r && m.c===c))
        cell.classList.add("highlight");

      const p = board[r][c];
      if (p) {
        const s = document.createElement("span");
        s.className = "piece " + p.c;
        s.textContent =
          p.t==="O" ? "O" :
          p.t==="D" ? "■" :
          p.t==="A" ? "▲" : "─";
        cell.appendChild(s);
      }

      cell.onclick = () => onCellClick(r,c);
      b.appendChild(cell);
    }
  }

  let status =
    gameOver ? "Spiel beendet" :
    (currentPlayer==="red" ? "Rot" : "Blau") + " ist am Zug";
  if(!gameOver && isInCheck(currentPlayer)) status += " (O bedroht!)";

  document.getElementById("status").textContent = status;
  document.getElementById("turnIndicator").style.background =
    currentPlayer==="red" ? "darkred" : "darkblue";

  const res = document.getElementById("result");
  if(resultText){
    res.style.display = "block";
    res.textContent = resultText;
  } else {
    res.style.display = "none";
    res.textContent = "";
  }
}

/* =====================
   Feedback / Ergebnis
===================== */
function setResult(text){
  if(resultText) return; // nur einmal setzen
  resultText = text;
  gameOver = true;
  // optional: einmaliger Hinweis
  try { alert(text); } catch(e) {}
}

function endIfGameOver(){
  // 1) Niederlagenregeln (Ecke / Positions-Matt)
  const outcome = computeOutcome();
  if(outcome){
    setResult(outcome);
    return true;
  }

  // 2) Remis durch 3x Stellungswiederholung
  if(isThreefoldRepetition()){
    setResult("Remis (3× Stellungswiederholung)");
    return true;
  }

  return false;
}

/* =====================
   Undo + History
===================== */
function saveState(){
  history.push({
    board: JSON.parse(JSON.stringify(board)),
    currentPlayer,
    gameOver,
    resultText,
    positionHistory: positionHistory.slice()
  });
}

function undoMove(){
  if(history.length===0) return;
  const last = history.pop();
  board = last.board;
  currentPlayer = last.currentPlayer;
  gameOver = last.gameOver;
  resultText = last.resultText;
  positionHistory = last.positionHistory;

  selected=null; possibleMoves=[];
  render();
}

/* =====================
   Hilfsfunktionen
===================== */
function inBounds(r,c){return r>=0&&r<ROWS&&c>=0&&c<COLS;}

function findO(color){
  for(let r=0;r<ROWS;r++)
    for(let c=0;c<COLS;c++)
      if(board[r][c]?.t==="O" && board[r][c].c===color) return {r,c};
  return null;
}

function countDefenders(color){
  let n=0;
  for(let r=0;r<ROWS;r++)
    for(let c=0;c<COLS;c++)
      if(board[r][c]?.t==="D"&&board[r][c].c===color) n++;
  return n;
}

function adjacentToDefender(r,c,color){
  for(let dr=-1;dr<=1;dr++)
    for(let dc=-1;dc<=1;dc++){
      if(!dr&&!dc)continue;
      const nr=r+dr,nc=c+dc;
      if(inBounds(nr,nc)&&board[nr][nc]?.t==="D"&&board[nr][nc].c===color)
        return true;
    }
  return false;
}

function adjacentToEnemyO(r,c,color){
  for(let dr=-1;dr<=1;dr++)
    for(let dc=-1;dc<=1;dc++){
      if(!dr&&!dc)continue;
      const nr=r+dr,nc=c+dc;
      if(inBounds(nr,nc)&&board[nr][nc]?.t==="O"&&board[nr][nc].c!==color)
        return true;
    }
  return false;
}

/* =====================
   Stellungs-Hash + 3x Wiederholung
===================== */
function positionHash(){
  // Hash inkl. side to move
  let s = currentPlayer + "|";
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const p = board[r][c];
      if(!p) s += ".";
      else s += (p.c==="red"?"r":"b") + p.t;
      s += ",";
    }
  }
  return s;
}

function pushPositionHash(){
  positionHistory.push(positionHash());
}

function isThreefoldRepetition(){
  if(positionHistory.length < 7) return false; // grobe Abkürzung
  const h = positionHistory[positionHistory.length - 1];
  let count = 0;
  for(const x of positionHistory) if(x === h) count++;
  return count >= 3;
}

/* =====================
   Bedrohung / Attack Moves
   (O kann NIE geschlagen werden -> andere Moves dürfen O nicht "capturen")
===================== */
function isThreatened(r,c,color){
  const enemy=color==="red"?"blue":"red";
  for(let rr=0;rr<ROWS;rr++)
    for(let cc=0;cc<COLS;cc++){
      const p=board[rr][cc];
      if(p && p.c===enemy){
        const attacks=getAttackMoves(rr,cc,p);
        if(attacks.some(m=>m.r===r && m.c===c)) return true;
      }
    }
  return false;
}

function getAttackMoves(r,c,p){
  if(p.t==="D") return rookAttackMoves(r,c,p);
  if(p.t==="A") return attackerAttackMoves(r,c,p);
  if(p.t==="S") return shieldAttackMoves(r,c,p); // diagonal wie Bauer
  if(p.t==="O"){
    const m=[];
    for(let dr=-1;dr<=1;dr++)
      for(let dc=-1;dc<=1;dc++){
        if(!dr&&!dc)continue;
        const nr=r+dr,nc=c+dc;
        if(inBounds(nr,nc)) m.push({r:nr,c:nc});
      }
    return m;
  }
  return [];
}

function rookAttackMoves(r,c,p){
  const m=[],d=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const[dr,dc]of d){
    let nr=r+dr,nc=c+dc;
    while(inBounds(nr,nc)){
      m.push({r:nr,c:nc});
      if(board[nr][nc]) break;
      nr+=dr; nc+=dc;
    }
  }
  return m;
}

function attackerAttackMoves(r,c,p){
  const m=[];
  const diag=[[1,1],[1,-1],[-1,1],[-1,-1]];
  for(const[dr,dc]of diag){
    let nr=r+dr,nc=c+dc;
    while(inBounds(nr,nc)){
      m.push({r:nr,c:nc});
      if(board[nr][nc]) break;
      nr+=dr; nc+=dc;
    }
  }
  const j=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  for(const[dr,dc]of j){
    const nr=r+dr,nc=c+dc;
    if(inBounds(nr,nc)) m.push({r:nr,c:nc});
  }
  return m;
}

function shieldAttackMoves(r,c,p){
  const m=[];
  const dir = p.c==="red" ? 1 : -1;
  const nr = r + dir;
  for(const dc of [-1, +1]){
    const nc = c + dc;
    if(inBounds(nr,nc)) m.push({r:nr,c:nc});
  }
  return m;
}

function isInCheck(color){
  const o = findO(color);
  if(!o) return false;
  return isThreatened(o.r, o.c, color);
}

/* =====================
   Zuglogik (Legal Moves)
===================== */
function getLegalMoves(r,c){
  const p = board[r][c];
  if(!p) return [];

  let moves = [];
  if(p.t==="O") moves = kingMoves(r,c,p);
  if(p.t==="D") moves = rookMoves(r,c,p);
  if(p.t==="A") moves = attackerMoves(r,c,p);
  if(p.t==="S") moves = shieldMoves(r,c,p);

  // Pin/King-Safety: Züge dürfen den eigenen O nicht in Schach lassen
  if(p.t!=="O"){
    moves = moves.filter(m => !wouldLeaveOInCheck(r,c,m.r,m.c,p.c,m));
  }

  // Wenn O bedroht ist: nur Züge, die das auflösen
  if(isInCheck(p.c)){
    moves = moves.filter(m => wouldResolveCheck(r,c,m.r,m.c,p.c,m));
  } else {
    // auch ohne Check: nach Zug darf O nicht bedroht sein
    moves = moves.filter(m => !wouldLeaveOInCheck(r,c,m.r,m.c,p.c,m));
  }

  // Für O selbst gilt auch: nicht in bedrohtes Feld ziehen
  if(p.t==="O"){
    moves = moves.filter(m => !wouldLeaveOInCheck(r,c,m.r,m.c,p.c,m));
  }

  return moves;
}

function kingMoves(r,c,p){
  const m=[],def=countDefenders(p.c);
  for(let dr=-1;dr<=1;dr++)
    for(let dc=-1;dc<=1;dc++){
      if(!dr&&!dc)continue;
      const nr=r+dr,nc=c+dc;
      if(!inBounds(nr,nc))continue;

      const t=board[nr][nc];
      if(t && t.c===p.c) continue;
      if(t && t.t==="S") continue; // O darf nicht auf Schild

      if(def>0 && !adjacentToDefender(nr,nc,p.c)) continue;
      if(adjacentToEnemyO(nr,nc,p.c)) continue;

      // O kann schlagen (auch A/D/S), aber wird später noch auf "nicht ins Schach" gefiltert
      m.push({r:nr,c:nc});
    }
  return m;
}

function rookMoves(r,c,p){
  const m=[],d=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const[dr,dc]of d){
    let nr=r+dr,nc=c+dc;
    while(inBounds(nr,nc)){
      const t=board[nr][nc];
      if(t){
        // O kann NIE geschlagen werden
        if(t.c!==p.c && t.t!=="O") m.push({r:nr,c:nc});
        break;
      }
      m.push({r:nr,c:nc});
      nr+=dr;nc+=dc;
    }
  }
  return m;
}

function attackerMoves(r,c,p){
  const m=[];
  const diag=[[1,1],[1,-1],[-1,1],[-1,-1]];
  for(const[dr,dc]of diag){
    let nr=r+dr,nc=c+dc;
    while(inBounds(nr,nc)){
      const t=board[nr][nc];
      if(t){
        if(t.c!==p.c && t.t!=="O") m.push({r:nr,c:nc});
        break;
      }
      m.push({r:nr,c:nc});
      nr+=dr;nc+=dc;
    }
  }
  const j=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  for(const[dr,dc]of j){
    const nr=r+dr,nc=c+dc;
    if(inBounds(nr,nc)){
      const t=board[nr][nc];
      if(!t || (t.c!==p.c && t.t!=="O")) m.push({r:nr,c:nc});
    }
  }
  return m;
}

function shieldMoves(r,c,p){
  const m=[];
  const dir = p.c==="red" ? 1 : -1;

  // Vorwärtszug
  const fr = r + dir;
  if(inBounds(fr,c) && !board[fr][c]){
    m.push({r:fr, c:c, suicide:false});
  }

  // Diagonal schlagen, Schild verschwindet danach
  for(const dc of [-1, +1]){
    const nr = r + dir;
    const nc = c + dc;
    if(!inBounds(nr,nc)) continue;
    const t = board[nr][nc];
    if(t && t.c !== p.c && t.t !== "O"){
      m.push({r:nr, c:nc, suicide:true});
    }
  }
  return m;
}

/* =====================
   Check-Simulation
===================== */
function wouldLeaveOInCheck(fr,fc,tr,tc,color,moveMeta){
  const a = board[fr][fc];
  const b = board[tr][tc];

  board[tr][tc] = a;
  board[fr][fc] = null;

  if(a?.t === "S" && moveMeta?.suicide){
    board[tr][tc] = null; // Schild verschwindet
  }

  const o = findO(color);
  const bad = o ? isThreatened(o.r, o.c, color) : false;

  board[fr][fc] = a;
  board[tr][tc] = b;

  return bad;
}

function wouldResolveCheck(fr,fc,tr,tc,color,moveMeta){
  return !wouldLeaveOInCheck(fr,fc,tr,tc,color,moveMeta);
}

/* =====================
   Umwandlung (Schild -> A oder D)
===================== */
function promotionRowFor(color){
  return color==="red" ? 7 : 0;
}

function maybePromoteShieldAt(r,c, isAI){
  const p = board[r][c];
  if(!p || p.t!=="S") return;

  const promoRow = promotionRowFor(p.c);
  if(r !== promoRow) return;

  // Schild ist nur da, wenn es NICHT im Suizid-Capture verschwunden ist
  let choice = "D"; // Default

  if(isAI){
    // simple KI: meistens ist D stabiler
    choice = "D";
  } else {
    choice = (prompt("Schild-Umwandlung! Tippe A (Angreifer) oder D (Verteidiger):", "D") || "D").toUpperCase();
    if(choice !== "A" && choice !== "D") choice = "D";
  }

  board[r][c] = {t: choice, c: p.c};
}

/* =====================
   Zug-Ausführung (mit Schild-Suizid + Umwandlung + Wiederholung)
===================== */
function makeMove(fr,fc,tr,tc,moveMeta, isAI=false){
  saveState();

  const piece = board[fr][fc];

  board[tr][tc] = piece;
  board[fr][fc] = null;

  // Schild-Suizid nach Capture
  if(piece?.t==="S" && moveMeta?.suicide){
    board[tr][tc] = null; // Schild verschwindet
  } else {
    // Schild-Promotion (nur wenn Schild noch existiert)
    maybePromoteShieldAt(tr,tc, isAI);
  }

  // Spielende prüfen (vor Spielerwechsel zählt noch nicht als neue Stellung)
  if(endIfGameOver()){
    render();
    return;
  }

  // Spieler wechseln
  currentPlayer = currentPlayer==="red" ? "blue" : "red";

  // Neue Stellung (inkl. side-to-move) für 3x Wiederholung erfassen
  pushPositionHash();

  // Remis/Wiederholung nach Seitenwechsel prüfen
  if(endIfGameOver()){
    render();
    return;
  }
}

/* =====================
   Klicklogik (Spieler)
===================== */
function onCellClick(r,c){
  if(gameOver) return;

  // Wenn KI dran ist (Blau), keine Eingaben annehmen
  if(currentPlayer === "blue" && AI_ENABLED) return;

  const p = board[r][c];

  if(!selected){
    if(p && p.c===currentPlayer){
      selected = {r,c};
      possibleMoves = getLegalMoves(r,c);
      render();
    }
    return;
  }

  const chosen = possibleMoves.find(m => m.r===r && m.c===c);

  if(chosen){
    makeMove(selected.r, selected.c, r, c, chosen, false);
    selected = null;
    possibleMoves = [];
    render();

    if(!gameOver && currentPlayer === "blue" && AI_ENABLED){
      setTimeout(aiTurn, 120);
    }
  } else {
    selected=null;
    possibleMoves=[];
    render();
  }
}

/* =====================
   Spielende / Outcome
===================== */
function isOLostByCorner(color){
  const o = findO(color);
  if(!o) return false;
  return (o.r===0 || o.r===7) && (o.c===0 || o.c===4);
}

function isPositionalMate(color){
  const o = findO(color);
  if(!o) return true;
  const p = board[o.r][o.c];
  const noMoves = kingMoves(o.r,o.c,p).filter(m => !wouldLeaveOInCheck(o.r,o.c,m.r,m.c,color,m)).length === 0;
  const threatened = isThreatened(o.r,o.c,color);
  return noMoves && threatened;
}

function computeOutcome(){
  const redLose  = isOLostByCorner("red")  || isPositionalMate("red");
  const blueLose = isOLostByCorner("blue") || isPositionalMate("blue");

  if(redLose && blueLose) return "Remis";
  if(redLose)  return "Rot verliert – Blau gewinnt!";
  if(blueLose) return "Blau verliert – Rot gewinnt!";
  return null;
}

/* =====================
   KI Gegner (Blau) - Minimax + AlphaBeta
   (unterstützt Schild-Suizid + Umwandlung)
===================== */
function aiTurn(){
  if(gameOver) return;
  if(!AI_ENABLED) return;
  if(currentPlayer !== "blue") return;

  const best = findBestMove("blue", AI_DEPTH);
  if(!best){
    setResult("Remis (keine legalen Züge)");
    render();
    return;
  }

  makeMove(best.fr, best.fc, best.tr, best.tc, best.meta, true);
  render();
}

function findBestMove(color, depth){
  const moves = getAllMoves(color);
  if(moves.length === 0) return null;

  // Captures zuerst
  moves.sort((a,b)=>{
    const ca = board[a.tr][a.tc] ? 1 : 0;
    const cb = board[b.tr][b.tc] ? 1 : 0;
    return cb - ca;
  });

  let bestMove = null;
  let bestScore = -Infinity;

  for(const mv of moves){
    const snap = snapshot();
    applyMove(mv, true);

    const score = minimax(depth - 1, -Infinity, Infinity, false, color);

    restore(snap);

    if(score > bestScore){
      bestScore = score;
      bestMove = mv;
    }
  }
  return bestMove;
}

function minimax(depth, alpha, beta, maximizing, aiColor){
  const term = terminalScore(aiColor);
  if(term !== null) return term;
  if(depth === 0) return evaluate(aiColor);

  const player = maximizing ? aiColor : (aiColor==="red" ? "blue" : "red");
  const moves = getAllMoves(player);

  if(moves.length === 0){
    return evaluate(aiColor);
  }

  moves.sort((a,b)=>{
    const ca = board[a.tr][a.tc] ? 1 : 0;
    const cb = board[b.tr][b.tc] ? 1 : 0;
    return cb - ca;
  });

  if(maximizing){
    let value = -Infinity;
    for(const mv of moves){
      const snap = snapshot();
      applyMove(mv, true);
      value = Math.max(value, minimax(depth-1, alpha, beta, false, aiColor));
      restore(snap);
      alpha = Math.max(alpha, value);
      if(beta <= alpha) break;
    }
    return value;
  } else {
    let value = Infinity;
    for(const mv of moves){
      const snap = snapshot();
      applyMove(mv, true);
      value = Math.min(value, minimax(depth-1, alpha, beta, true, aiColor));
      restore(snap);
      beta = Math.min(beta, value);
      if(beta <= alpha) break;
    }
    return value;
  }
}

/* ---------- KI Move helpers ---------- */
function getAllMoves(color){
  const moves = [];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const p = board[r][c];
      if(!p || p.c !== color) continue;

      const legals = getLegalMoves(r,c);
      for(const m of legals){
        moves.push({fr:r, fc:c, tr:m.r, tc:m.c, meta:m});
      }
    }
  }
  return moves;
}

function snapshot(){
  return {
    board: JSON.parse(JSON.stringify(board)),
    currentPlayer,
    gameOver,
    resultText,
    selected: selected ? {...selected} : null,
    possibleMoves: possibleMoves ? possibleMoves.map(x=>({...x})) : [],
    positionHistory: positionHistory.slice()
  };
}

function restore(snap){
  board = snap.board;
  currentPlayer = snap.currentPlayer;
  gameOver = snap.gameOver;
  resultText = snap.resultText;
  selected = snap.selected;
  possibleMoves = snap.possibleMoves;
  positionHistory = snap.positionHistory;
}

function applyMove(mv, isAI){
  const piece = board[mv.fr][mv.fc];
  board[mv.tr][mv.tc] = piece;
  board[mv.fr][mv.fc] = null;

  if(piece?.t==="S" && mv.meta?.suicide){
    board[mv.tr][mv.tc] = null;
  } else {
    maybePromoteShieldAt(mv.tr, mv.tc, isAI);
  }
}

/* ---------- KI Evaluation ---------- */
function terminalScore(aiColor){
  const out = computeOutcome();
  if(out){
    if(out.startsWith("Remis")) return 0;
    if(out.includes("Blau gewinnt")) return aiColor==="blue" ? +1e9 : -1e9;
    if(out.includes("Rot gewinnt"))  return aiColor==="red"  ? +1e9 : -1e9;
    return 0;
  }
  // Drei-Zug-Wiederholung wird in der Suche ignoriert (nur im echten Spielzug gezählt)
  return null;
}

function evaluate(aiColor){
  const me  = aiColor;
  const opp = aiColor==="red" ? "blue" : "red";

  const val = { O: 2000, D: 80, A: 60, S: 12 };
  let score = 0;

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const p = board[r][c];
      if(!p) continue;
      const v = val[p.t] ?? 0;
      score += (p.c===me ? v : -v);
    }
  }

  score += 2 * (getAllMoves(me).length - getAllMoves(opp).length);

  const myO  = findO(me);
  const oppO = findO(opp);

  if(myO && isThreatened(myO.r, myO.c, me)) score -= 140;
  if(oppO && isThreatened(oppO.r, oppO.c, opp)) score += 140;

  if(myO)  score -= 12 * cornerProximityPenalty(myO.r, myO.c);
  if(oppO) score += 12 * cornerProximityPenalty(oppO.r, oppO.c);

  score += 10 * (countDefenders(me) - countDefenders(opp));

  return score;
}

function cornerProximityPenalty(r,c){
  const corners = [{r:0,c:0},{r:0,c:4},{r:7,c:0},{r:7,c:4}];
  let best = Infinity;
  for(const k of corners){
    const d = Math.abs(r-k.r) + Math.abs(c-k.c);
    if(d < best) best = d;
  }
  return Math.max(0, 6 - best);
}

/* =====================
   Service Worker Registrierung (optional/offline)
===================== */
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker.register("./sw.js").catch(()=>{});
  });
}
</script>
</body>
</html>